name: Build Image
on:
  workflow_call:
    inputs:
      image-name:
        description: "The name of the image to build"
        required: true
        type: string
      image-desc:
        description: "The description of the image to build"
        required: false
        type: string
        default: "Bluefin LTS, built on CentOS Stream with bootc"
      flavor:
        description: "The flavor of the image to build"
        required: false
        type: string
        default: ""
      platforms:
        description: "Comma-separated list of platforms to build for (e.g., amd64,arm64)"
        required: false
        type: string
        default: "amd64,arm64"
      major-version:
        description: "The version of CentOS to build the image on"
        required: false
        type: string
        default: "10"
      default-tag:
        description: "The default tag to use for the image"
        required: false
        type: string
        default: "lts"
      rechunk:
        description: "Rechunk the build"
        required: false
        type: boolean
        default: true
      sbom:
        description: "Generate/publish SBOMs for the artifacts"
        required: false
        type: boolean
        default: true
      cleanup_runner:
        description: "Use the ublue cleanup action to clean up the runner before running the build"
        required: false
        type: boolean
        default: true
      publish:
        description: "Publish this image. Defaults to true if not a pull request."
        required: false
        type: boolean
        default: ${{ github.event_name != 'pull_request' }}
    secrets:
      SIGNING_SECRET:
        description: "The private key used to sign the image. If not provided, signing steps are skipped."
        required: false

env:
  IMAGE_NAME: ${{ inputs.image-name }}
  IMAGE_DESC: ${{ inputs.image-desc }}
  IMAGE_REGISTRY: "ghcr.io/${{ github.repository_owner }}"
  DEFAULT_TAG: ${{ inputs.default-tag }}
  MAJOR_VERSION: ${{ inputs.major-version }}

jobs:
  prepare_matrix:
    name: Prepare Build Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Create matrix string from platforms input
        id: set-matrix
        run: |
          platforms="${{ inputs.platforms }}"
          json_array="[\"$(echo $platforms | sed 's/,/\",\"/g')\"]"
          echo "matrix=${json_array}" >> $GITHUB_OUTPUT

  build_push:
    name: Build and Push on ${{ matrix.platform }}
    runs-on: ${{ (matrix.platform == 'amd64/v2' && 'ubuntu-24.04') || (matrix.platform == 'amd64' && 'ubuntu-24.04') || 'ubuntu-24.04-arm' }}
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        platform: ${{ fromJSON(needs.prepare_matrix.outputs.matrix) }}
    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Install dependencies
        if: matrix.platform == 'arm64'
        run: |
          sudo apt update -y && sudo apt install -y podman

      - name: Checkout
        uses: actions/checkout@v4

      - name: Maximize build space
        if: ${{ matrix.platform != 'arm64' && inputs.cleanup_runner }}
        uses: ublue-os/remove-unwanted-software@v9
        with:
          remove-codeql: true

      - name: Setup Just
        uses: extractions/setup-just@v3

      - name: Check Just Syntax
        run: just check

      - name: Build Image
        id: build-image
        env:
          FLAVOR: ${{ inputs.flavor }}
        run: |
          set -x
          ENABLE_GDX=0
          ENABLE_DX=0
          if [[ "${FLAVOR}" =~ "gdx" ]]; then ENABLE_GDX=1; fi
          if [[ "${FLAVOR}" =~ "dx" ]]; then ENABLE_DX=1; fi
          sudo just build "${IMAGE_NAME}" "${DEFAULT_TAG}" "${ENABLE_DX}" "${ENABLE_GDX}"

      - name: Setup Syft
        if: ${{ inputs.sbom && inputs.publish }}
        uses: anchore/sbom-action/download-syft@v0
        id: setup-syft

      - name: Generate SBOM
        if: ${{ inputs.sbom && inputs.publish }}
        id: generate-sbom
        env:
          IMAGE: ${{ env.IMAGE_NAME }}
          DEFAULT_TAG: ${{ env.DEFAULT_TAG }}
          SYFT_CMD: ${{ steps.setup-syft.outputs.cmd }}
        run: |
          sudo systemctl start podman.socket
          OUTPUT_PATH="$(mktemp -d)/sbom.json"
          export SYFT_PARALLELISM=$(($(nproc)*2))
          sudo "$SYFT_CMD" "${IMAGE}:${DEFAULT_TAG}" -o "spdx-json=${OUTPUT_PATH}"
          echo "OUTPUT_PATH=${OUTPUT_PATH}" >> "${GITHUB_OUTPUT}"

      - name: Run Rechunker
        if: ${{ inputs.rechunk && inputs.publish }}
        id: rechunk
        uses: hhd-dev/rechunk@v1.2.2
        with:
          rechunk: ghcr.io/hhd-dev/rechunk:v1.2.1
          ref: localhost/${{ env.IMAGE_NAME }}:${{ env.DEFAULT_TAG }}
          prev-ref: ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.DEFAULT_TAG }}
          skip_compression: true
          version: ${{ env.MAJOR_VERSION }}

      - name: Login to GHCR
        if: ${{ inputs.publish }}
        run: echo "${{ secrets.GITHUB_TOKEN }}" | podman login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Push Image
        if: ${{ inputs.publish }}
        id: push
        run: |
          set -x
          IMAGE_TO_PUSH="${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.DEFAULT_TAG }}"
          
          LOCAL_IMAGE_REF="localhost/${{ env.IMAGE_NAME }}:${{ env.DEFAULT_TAG }}"
          if [ "${{ inputs.rechunk }}" == "true" ] && [ -n "${{ steps.rechunk.outputs.ref }}" ]; then
            LOCAL_IMAGE_REF="${{ steps.rechunk.outputs.ref }}"
          fi
          podman tag "${LOCAL_IMAGE_REF}" "${IMAGE_TO_PUSH}"
          
          podman push --retry=3 --retry-delay=5s --digestfile=/tmp/digestfile "${IMAGE_TO_PUSH}" --arch "${{ matrix.platform }}"
          
          echo "remote_image_digest=$(cat /tmp/digestfile)" >> "$GITHUB_OUTPUT"

      - name: Add SBOM Attestation
        if: ${{ inputs.sbom && inputs.publish }}
        env:
          IMAGE: ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}
          DIGEST: ${{ steps.push.outputs.remote_image_digest }}
          COSIGN_PRIVATE_KEY: ${{ secrets.SIGNING_SECRET }}
          SBOM_OUTPUT: ${{ steps.generate-sbom.outputs.OUTPUT_PATH }}
        run: |
          cd "$(dirname "$SBOM_OUTPUT")"
          TYPE="urn:ublue-os:attestation:spdx+json+zstd:v1"
          zstd -19 "./sbom.json" -o "./sbom.json.zst"
          PREDICATE_FILE="payload.json"
          jq -n \
            --arg compression "zstd" \
            --arg mediaType "application/spdx+json" \
            --rawfile payload <(base64 -w0 "./sbom.json.zst") \
            '{compression: $compression, mediaType: $mediaType, payload: $payload}' \
            > "$PREDICATE_FILE"
          cosign attest -y --predicate "${PREDICATE_FILE}" --type $TYPE --key env://COSIGN_PRIVATE_KEY "${IMAGE}@${DIGEST}"

      - name: Create Job Outputs
        if: ${{ inputs.publish }}
        run: |
          PLATFORM_SLUG=$(echo "${{ matrix.platform }}" | tr '/' '-')
          mkdir -p /tmp/outputs
          echo "${{ steps.push.outputs.remote_image_digest }}" > "/tmp/outputs/${{ env.IMAGE_NAME }}-${PLATFORM_SLUG}.txt"

      - name: Upload Digest Artifact
        if: ${{ inputs.publish }}
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ matrix.platform }}
          path: /tmp/outputs/

  manifest:
    name: Create and Push Manifest
    runs-on: ubuntu-latest
    if: ${{ inputs.publish }}
    needs: [prepare_matrix, build_push]
    permissions:
      contents: read
      packages: write
      id-token: write
    outputs:
      image: ${{ steps.push_manifest.outputs.IMAGE }}
      digest: ${{ steps.push_manifest.outputs.DIGEST }}

    steps:
      - name: Check build job status
        if: needs.build_push.result != 'success'
        run: echo "A build job failed. Aborting manifest creation." && exit 1

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y jq podman

      - name: Get current date for OCI spec
        id: date
        run: echo "date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      - name: Generate Image Metadata
        id: metadata
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ env.DEFAULT_TAG}}
            type=raw,value=${{ env.MAJOR_VERSION }}-server
            type=raw,value=${{ env.MAJOR_VERSION }}-server.{{date 'YYYYMMDD'}}
            type=ref,event=pr
          labels: |
            io.artifacthub.package.readme-url=https://raw.githubusercontent.com/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}/main/README.md
            org.opencontainers.image.created=${{ steps.date.outputs.date }}
            org.opencontainers.image.description=${{ env.IMAGE_DESC }}
            org.opencontainers.image.documentation=https://docs.projectbluefin.io
            org.opencontainers.image.source=https://github.com/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}/blob/main/Containerfile
            org.opencontainers.image.title=${{ env.IMAGE_NAME }}
            org.opencontainers.image.url=https://projectbluefin.io
            org.opencontainers.image.vendor=${{ github.repository_owner }}
            org.opencontainers.image.version=${{ env.MAJOR_VERSION }}

      - name: Download all digest artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: digests-*
          path: /tmp/digests
          merge-multiple: true

      - name: Create, Annotate, and Push Manifest
        id: push_manifest
        env:
          MANIFEST_NAME: "${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}"
          TAGS: ${{ steps.metadata.outputs.tags }}
          LABELS: ${{ steps.metadata.outputs.labels }}
        run: |
          set -e -x
          
          podman manifest create "${MANIFEST_NAME}"
          
          for digest_file in /tmp/digests/*.txt; do
            digest=$(cat "${digest_file}")
            echo "Adding digest ${digest} to manifest"
            podman manifest add "${MANIFEST_NAME}" "docker://${MANIFEST_NAME}@${digest}"
          done
          
          while IFS= read -r label; do
            podman manifest annotate "${MANIFEST_NAME}" --annotation "${label}"
          done <<< "${LABELS}"
          
          echo "${{ secrets.GITHUB_TOKEN }}" | podman login ghcr.io -u "${{ github.actor }}" --password-stdin
          
          digest_file_output="/tmp/final_digest.txt"
          while IFS= read -r tag; do
            podman manifest push --all "${MANIFEST_NAME}" "docker://${tag}" --digestfile "${digest_file_output}"
          done <<< "${TAGS}"

          echo "DIGEST=$(cat ${digest_file_output})" >> "$GITHUB_OUTPUT"
          echo "IMAGE=${MANIFEST_NAME}" >> "$GITHUB_OUTPUT"

  sign_manifest:
    name: Sign Manifest
    runs-on: ubuntu-latest
    needs: manifest
    if: ${{ github.event_name != 'pull_request' }}
    permissions:
      packages: write
      id-token: write
    steps:
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Login to GHCR with Cosign
        run: echo "${{ secrets.GITHUB_TOKEN }}" | cosign login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Sign Manifest
        env:
          COSIGN_PRIVATE_KEY: ${{ secrets.SIGNING_SECRET }}
        run: |
          cosign sign -y --key env://COSIGN_PRIVATE_KEY \
            "${{ needs.manifest.outputs.image }}@${{ needs.manifest.outputs.digest }}"